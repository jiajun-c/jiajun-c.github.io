<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HalfStar</title>
  
  <subtitle>coding, traveling and gym</subtitle>
  <link href="http://www.halfstar.top/atom.xml" rel="self"/>
  
  <link href="http://www.halfstar.top/"/>
  <updated>2022-03-03T09:07:03.380Z</updated>
  <id>http://www.halfstar.top/</id>
  
  <author>
    <name>jiajun-c</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k点最短路</title>
    <link href="http://www.halfstar.top/2022/03/03/k/"/>
    <id>http://www.halfstar.top/2022/03/03/k/</id>
    <published>2022-03-03T08:05:07.000Z</published>
    <updated>2022-03-03T09:07:03.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K点最短路"><a href="#K点最短路" class="headerlink" title="K点最短路"></a>K点最短路</h1><p>在OI中,有一类经典的问题叫做经过K点的最短路径, 解题的思路大致是利用flyod和之前我们学习过的广义矩阵乘法, 矩阵快速幂</p><h2 id="1-分析"><a href="#1-分析" class="headerlink" title="1. 分析"></a>1. 分析</h2><p>对于K点的最短路, 我们可以当作是一个传递闭包进行处理,k一定是可以被分解为是2的 $k_i$ 次方的相加, 如果一个传递闭包的级数为k,另外一个的级数为p,那么将这两个相称得到的就是进行k+p次的闭包</p><p>我们可以将最短路同理为闭包, K级就意味着在k个点上的最短路径, k+p则是他们和的点数的最短路径, 对于这个闭包运算的实现, 我们可以使用广义矩阵乘法</p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2 代码"></a>2 代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 520</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[N][N], vis[<span class="number">1001000</span>];</span><br><span class="line"><span class="type">int</span> n,t,s,e,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span> &#123;</span><br><span class="line">    <span class="type">int</span> dis[N][N];</span><br><span class="line">    matrix <span class="keyword">operator</span>*(<span class="type">const</span> matrix&amp;x) <span class="type">const</span> &#123;</span><br><span class="line">        matrix c;</span><br><span class="line">        <span class="built_in">memset</span>(c.dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> c.dis);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= cnt; k++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)</span><br><span class="line">                    c.dis[i][j] = <span class="built_in">min</span>(c.dis[i][j], dis[i][k] + x.dis[k][j]);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;now,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(now.dis,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(now.dis));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;t,&amp;s,&amp;e);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= t;i++) &#123;</span><br><span class="line">        <span class="type">int</span> x,y,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;d,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(!vis[x]) &#123;vis[x] = ++cnt;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!vis[y]) &#123;vis[y] = ++cnt;&#125;</span><br><span class="line">        now.dis[vis[x]][vis[y]] = now.dis[vis[y]][vis[x]] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    ans = now;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans = ans*now;</span><br><span class="line">        now = now*now;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.dis[vis[s]][vis[e]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;K点最短路&quot;&gt;&lt;a href=&quot;#K点最短路&quot; class=&quot;headerlink&quot; title=&quot;K点最短路&quot;&gt;&lt;/a&gt;K点最短路&lt;/h1&gt;&lt;p&gt;在OI中,有一类经典的问题叫做经过K点的最短路径, 解题的思路大致是利用flyod和之前我们学习过的广义矩阵乘法, </summary>
      
    
    
    
    <category term="ACM" scheme="http://www.halfstar.top/categories/ACM/"/>
    
    
    <category term="图论" scheme="http://www.halfstar.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://www.halfstar.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>objdump</title>
    <link href="http://www.halfstar.top/2022/03/02/objdump/"/>
    <id>http://www.halfstar.top/2022/03/02/objdump/</id>
    <published>2022-03-02T14:13:02.000Z</published>
    <updated>2022-03-02T15:14:36.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="liunx下反汇编"><a href="#liunx下反汇编" class="headerlink" title="liunx下反汇编"></a>liunx下反汇编</h1><p>在linux下的反汇编我们主要是使用objdump，其实也可以在我们的gdb下面对我们需要的section进行反汇编</p><ul><li>-f 显示文件头信息</li><li>-D 反汇编所有section (-d反汇编特定section)</li><li>-h 显示目标文件各个section的头部摘要信息</li><li>-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。</li><li>-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。</li><li>-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。</li><li>-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。</li><li>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。</li><li>-t 显示文件的符号表入口。类似于nm -s提供的信息</li></ul><h2 id="查看机器的大小端"><a href="#查看机器的大小端" class="headerlink" title="查看机器的大小端"></a>查看机器的大小端</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -i  </span><br></pre></td></tr></table></figure><h2 id="进行反汇编"><a href="#进行反汇编" class="headerlink" title="进行反汇编"></a>进行反汇编</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d main.o </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">start debug in the linux</summary>
    
    
    
    <category term="linux" scheme="http://www.halfstar.top/categories/linux/"/>
    
    
    <category term="linux" scheme="http://www.halfstar.top/tags/linux/"/>
    
    <category term="assemble" scheme="http://www.halfstar.top/tags/assemble/"/>
    
  </entry>
  
  <entry>
    <title>gdb.md</title>
    <link href="http://www.halfstar.top/2022/03/02/gdb/"/>
    <id>http://www.halfstar.top/2022/03/02/gdb/</id>
    <published>2022-03-02T13:17:03.000Z</published>
    <updated>2022-03-02T14:30:17.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB-调试"><a href="#GDB-调试" class="headerlink" title="GDB 调试"></a>GDB 调试</h1><h2 id="0-pre-work"><a href="#0-pre-work" class="headerlink" title="0. pre work"></a>0. pre work</h2><p>在一些文章中看到需要在编译的时候加入-g的参数才能进行调试<br>加入gdb参数的编译指令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -o hello hello.c </span><br></pre></td></tr></table></figure><h3 id="0-1-check-file"><a href="#0-1-check-file" class="headerlink" title="0.1 check file"></a>0.1 check file</h3><p>我们可以使用readelf对<a href="./wiki/ELF.md">elf</a>文件进行查看,使用grep我们可以抓取到我们想要的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="language-bash">linux readelf -S hello|grep plt</span>  </span><br><span class="line">  [11] .rela.plt         RELA             0000000000000608  00000608</span><br><span class="line">  [13] .plt              PROGBITS         0000000000001020  00001020</span><br><span class="line">  [14] .plt.got          PROGBITS         0000000000001050  00001050</span><br><span class="line">  [15] .plt.sec          PROGBITS         0000000000001060  00001060</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译产生可执行文件后对其进行调试<br>按道理说到这里我们已经可以看出这个程序是否是可以调试的，但是原文的作者还教会了我们另外一种方式<br><code>file hello|grep strip</code><br>在得到的信息中如果显示not stripped说明调试相关的信息没有被抹除，还保存在文件中，否则不能进行调试</p><h2 id="1-Start-debug"><a href="#1-Start-debug" class="headerlink" title="1 Start debug"></a>1 Start debug</h2><p>首先让我们写一个helloworld</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> &gt;= argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage:hello name\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World %s!\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照上文所说启动调试之后就可以start了</p><h3 id="1-1-Run"><a href="#1-1-Run" class="headerlink" title="1.1 Run"></a>1.1 Run</h3><p>run的基本用法和我们平时执行是差不多的，在提供了arg的情况下可以直接使用run + args的形式进行运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/chengjiajun/note/csapp/code/hello </span><br><span class="line">usage:hello name</span><br><span class="line">[Inferior 1 (process 48755) exited normally]</span><br><span class="line">(gdb) run A</span><br><span class="line">Starting program: /home/chengjiajun/note/csapp/code/hello A</span><br><span class="line">Hello World A!</span><br><span class="line">[Inferior 1 (process 48775) exited normally]</span><br><span class="line">gdb hello </span><br></pre></td></tr></table></figure><p>也可以提前设置好arg的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args SSR</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/chengjiajun/note/csapp/code/hello SSR</span><br><span class="line">Hello World SSR!</span><br><span class="line">[Inferior 1 (process 48831) exited normally]</span><br></pre></td></tr></table></figure><h3 id="1-2-调试core文件"><a href="#1-2-调试core文件" class="headerlink" title="1.2 调试core文件"></a>1.2 调试core文件</h3><p>当我们在机器中执行<code>ulimit -c</code> 可以查看系统是否对core文件的产生进行限制<br>如果结果为0，那么当程序结束的时候也不会有core文件产生。<br>此时我们需要进行如下的设置<br><a href="https://www.yanbinghu.com/2018/09/26/61877.html">对core的调试waiting</a></p><h2 id="2-断点调试"><a href="#2-断点调试" class="headerlink" title="2 断点调试"></a>2 断点调试</h2><h3 id="2-1-查看已经存在的断点"><a href="#2-1-查看已经存在的断点" class="headerlink" title="2.1 查看已经存在的断点"></a>2.1 查看已经存在的断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints</span><br></pre></td></tr></table></figure><h3 id="2-2-设置断点"><a href="#2-2-设置断点" class="headerlink" title="2.2 设置断点"></a>2.2 设置断点</h3><h4 id="2-2-1-在第i行设置一个断点"><a href="#2-2-1-在第i行设置一个断点" class="headerlink" title="2.2.1 在第i行设置一个断点"></a>2.2.1 在第i行设置一个断点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b 9 </span><br></pre></td></tr></table></figure><h4 id="2-2-2-为一个函数设置一个断点"><a href="#2-2-2-为一个函数设置一个断点" class="headerlink" title="2.2.2 为一个函数设置一个断点"></a>2.2.2 为一个函数设置一个断点</h4><p>b [function name] 实现了在函数执行处设置断点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb)b add </span><br></pre></td></tr></table></figure><h4 id="2-2-3-根据条件设置断点"><a href="#2-2-3-根据条件设置断点" class="headerlink" title="2.2.3 根据条件设置断点"></a>2.2.3 根据条件设置断点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 10 if x==11</span><br><span class="line">Note: breakpoint 3 also set at pc 0x1194.</span><br><span class="line">Breakpoint 4 at 0x1194: file hello.c, line 10.</span><br><span class="line">(gdb) info breakpoints </span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000001149 in add at hello.c:2</span><br><span class="line">2       breakpoint     keep y   0x0000000000001161 in add at hello.c:4</span><br><span class="line">3       breakpoint     keep y   0x0000000000001194 in main at hello.c:10</span><br><span class="line">4       breakpoint     keep y   0x0000000000001194 in main at hello.c:10</span><br><span class="line">stop only if x==11</span><br></pre></td></tr></table></figure><h4 id="2-2-4-根据规则设置断点"><a href="#2-2-4-根据规则设置断点" class="headerlink" title="2.2.4 根据规则设置断点"></a>2.2.4 根据规则设置断点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbreak printNum*</span><br></pre></td></tr></table></figure><p>这样就可以在所有符合规则的地方设置断点</p><p>其他断点的设置方式参考 <a href="https://www.yanbinghu.com/2019/04/20/41283.html">link</a></p><h3 id="2-3-清除断点"><a href="#2-3-清除断点" class="headerlink" title="2.3 清除断点"></a>2.3 清除断点</h3><h4 id="禁用或启用断点"><a href="#禁用或启用断点" class="headerlink" title="禁用或启用断点"></a>禁用或启用断点</h4><p>如果加入了编号，就说明是对某一个断点进行操作，如果不仅爱如数字，就说明是对所有的断点进行的操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb)disable bnum </span><br><span class="line">(gdb)endable bnum </span><br></pre></td></tr></table></figure><h4 id="断点的清除"><a href="#断点的清除" class="headerlink" title="断点的清除"></a>断点的清除</h4><p>clear + linenum&#x2F;function name&#x2F;filename: function name </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear add</span><br><span class="line"></span><br><span class="line">(gdb) info breakpoints </span><br><span class="line">Deleted breakpoint 1 No breakpoints or watchpoints.</span><br><span class="line">(gdb) info breakpoints </span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">2       breakpoint     keep y   0x000000000000115b in add at hello.c:3</span><br><span class="line">(gdb) d 2</span><br><span class="line">(gdb) info breakpoints </span><br><span class="line">No breakpoints or watchpoints</span><br></pre></td></tr></table></figure><h2 id="3-变量查看"><a href="#3-变量查看" class="headerlink" title="3.变量查看"></a>3.变量查看</h2><h3 id="普通变量的查看"><a href="#普通变量的查看" class="headerlink" title="普通变量的查看"></a>普通变量的查看</h3><p>准备好之前的调试工具后，在相应的位置设置断点，然后在该位置程序会停下<br>此时<code>p varname</code>可以显示变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint <span class="number">4</span>, main (argc=<span class="number">1</span>, argv=<span class="number">0x7fffffffde58</span>) at hello.c:<span class="number">10</span></span><br><span class="line"><span class="number">10</span>    x += <span class="number">1</span>;</span><br><span class="line">(gdb) p <span class="number">4</span></span><br><span class="line">$<span class="number">2</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="指针-x2F-数组的查看"><a href="#指针-x2F-数组的查看" class="headerlink" title="指针&#x2F;数组的查看"></a>指针&#x2F;数组的查看</h3><p>如果你直接p pointname， 得到的将是地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p p1</span><br><span class="line"><span class="meta">$</span><span class="language-bash">6 = (int *) 0x55555555527d &lt;__libc_csu_init+77&gt;</span></span><br></pre></td></tr></table></figure><p>想要打印数组的名字，必须使用<code>p *pointname</code>（只打印第一个数字）<br>如果想要限定输出的数字，则需要<code>p *pointname@num</code> (将会打印数组中的前num个元素<br>)</p><blockquote><p>其中值得注意的一点是我们的数组名和指针其实是不同的，在gdb的打印中打印一个数组名输出的是整个数组，而打印指针输出的是地址，数组名是一种直接的访问，是真实的地址，但是对于我们的指针而言，得到的将是一个地址，运行这个地址我们可以得到真实内存所在的地方。</p></blockquote><h3 id="设置我们自己的变量"><a href="#设置我们自己的变量" class="headerlink" title="设置我们自己的变量"></a>设置我们自己的变量</h3><p>在调试的过程中，我们可以通过set指令去设置一个变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set $index = 1</span><br><span class="line">(gdb) $index</span><br><span class="line">Undefined command: &quot;$index&quot;.  Try &quot;help&quot;.</span><br><span class="line">(gdb) index</span><br><span class="line">Undefined command: &quot;index&quot;.  Try &quot;help&quot;.</span><br><span class="line">(gdb) p y[$index]</span><br><span class="line"><span class="meta">$</span><span class="language-bash">10 = 2</span></span><br><span class="line">(gdb) $index++</span><br><span class="line">Undefined command: &quot;$index++&quot;.  Try &quot;help&quot;.</span><br><span class="line">(gdb) index++</span><br><span class="line">Undefined command: &quot;index++&quot;.  Try &quot;help&quot;.</span><br><span class="line">(gdb) p y[$index++]</span><br><span class="line"><span class="meta">$</span><span class="language-bash">11 = 2</span></span><br><span class="line">(gdb) p y[$index]</span><br><span class="line"><span class="meta">$</span><span class="language-bash">12 = 3</span></span><br></pre></td></tr></table></figure><h3 id="进行函数的调试"><a href="#进行函数的调试" class="headerlink" title="进行函数的调试"></a>进行函数的调试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line">  add(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> &#123;</span><br><span class="line">  x += y;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用上面的代码作为例子<br>在对函数进行调试的时候，我们需要在函数中设置断点，然后在调用处使用<code>step</code>指令进入该函数的主体中。<br>If we use the <code>stepi</code>,it will go in the machine code </p><h3 id="调试中的跳转"><a href="#调试中的跳转" class="headerlink" title="调试中的跳转"></a>调试中的跳转</h3><table><thead><tr><th>command</th><th>role</th></tr></thead><tbody><tr><td>continue</td><td>go to the next breakpoint</td></tr><tr><td>until</td><td>go to the specific line</td></tr></tbody></table><h3 id="监控变量的变化"><a href="#监控变量的变化" class="headerlink" title="监控变量的变化"></a>监控变量的变化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) wathc varname</span><br></pre></td></tr></table></figure><p>每次变量有变化的时候程序都会停止执行</p>]]></content>
    
    
    <summary type="html">start debug in the linux</summary>
    
    
    
    <category term="linux" scheme="http://www.halfstar.top/categories/linux/"/>
    
    
    <category term="gdb" scheme="http://www.halfstar.top/tags/gdb/"/>
    
    <category term="debug" scheme="http://www.halfstar.top/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>csapp</title>
    <link href="http://www.halfstar.top/2022/03/02/csapp/"/>
    <id>http://www.halfstar.top/2022/03/02/csapp/</id>
    <published>2022-03-02T12:08:16.000Z</published>
    <updated>2022-03-03T04:36:00.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-lab"><a href="#Data-lab" class="headerlink" title="Data lab"></a>Data lab</h1><p>鸽</p><h1 id="Bomb-lab"><a href="#Bomb-lab" class="headerlink" title="Bomb lab"></a>Bomb lab</h1><h2 id="0-pre"><a href="#0-pre" class="headerlink" title="0. pre"></a>0. pre</h2><p><a href="http://www.csapp.cs.cmu.edu/3e/labs.html">the link</a><br>You can go to this website to download the &#x3D;&#x3D;self-study handout&#x3D;&#x3D;<br>In the folder, you can see three file, bomb, bomb.c README.md , the extra files are my works.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">── ans.txt</span><br><span class="line">├── bomb</span><br><span class="line">├── bomb.c</span><br><span class="line">├── bomb.md</span><br><span class="line">├── out.txt</span><br><span class="line">└── README</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> directories, <span class="number">6</span> files</span><br></pre></td></tr></table></figure><p>在本次的实验中，你还需要一些前置知识，比如</p><ul><li><a href="https://jiajun-c.github.io/2022/03/02/gdb/">gdb debug</a></li><li><a href="">objump</a><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2>在该lab中，你需要去拆解六个“炸弹”，你将通过反汇编去找寻这六个炸弹的线索<blockquote><p>A tip: 在原来的程序中一定存在着比较的语句</p></blockquote></li></ul><h2 id="2-Start-defuse"><a href="#2-Start-defuse" class="headerlink" title="2. Start defuse"></a>2. Start defuse</h2><h3 id="2-1-bomb-one"><a href="#2-1-bomb-one" class="headerlink" title="2.1 bomb one"></a>2.1 bomb one</h3><p>首先我们使用gdb对程序进行调试，在phase_1的地方设置断点， 进入断点之后我们开始反汇编，在gdb窗口中使用<code>disas</code>对我们的section进行反汇编，得到的结果是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_1:</span><br><span class="line">=&gt; 0x0000000000400ee0 &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:mov    $0x402400,%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:callq  0x401338 &lt;strings_not_equal&gt;</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:je     0x400ef7 &lt;phase_1+23&gt;</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>You can see there is a <strings_not_equal>, if the string you input is not equal to the target one, the bomb wil bome.<br>We can guess that the string is storaged in the $0x402400, check the string storaged in the 0x402400, you can get the ans.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:&quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-bomb-two"><a href="#2-2-bomb-two" class="headerlink" title="2.2 bomb two"></a>2.2 bomb two</h3><p>同样在phase_2处打下断点，然后进行调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1, 0x0000000000400efc in phase_2 ()</span><br><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_2:</span><br><span class="line">=&gt; 0x0000000000400efc &lt;+0&gt;:push   %rbp</span><br><span class="line">   0x0000000000400efd &lt;+1&gt;:push   %rbx</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:sub    $0x28,%rsp</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:callq  0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x0000000000400f0a &lt;+14&gt;:cmpl   $0x1,(%rsp)</span><br><span class="line">   0x0000000000400f0e &lt;+18&gt;:je     0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f10 &lt;+20&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f15 &lt;+25&gt;:jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax</span><br><span class="line">   0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax</span><br><span class="line">   0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)</span><br><span class="line">   0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;</span><br><span class="line">   0x0000000000400f20 &lt;+36&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx</span><br><span class="line">   0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx</span><br><span class="line">   0x0000000000400f2c &lt;+48&gt;:jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f2e &lt;+50&gt;:jmp    0x400f3c &lt;phase_2+64&gt;</span><br><span class="line">   0x0000000000400f30 &lt;+52&gt;:lea    0x4(%rsp),%rbx</span><br><span class="line">   0x0000000000400f35 &lt;+57&gt;:lea    0x18(%rsp),%rbp</span><br><span class="line">   0x0000000000400f3a &lt;+62&gt;:jmp    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f3c &lt;+64&gt;:add    $0x28,%rsp</span><br><span class="line">   0x0000000000400f40 &lt;+68&gt;:pop    %rbx</span><br><span class="line">   0x0000000000400f41 &lt;+69&gt;:pop    %rbp</span><br><span class="line">   0x0000000000400f42 &lt;+70&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>看到上面的<code>&lt;read_six_numbers&gt;</code>我们可以知道这次是让我们去输入六个数字<br>Then we can see <code>cmpl   $0x1,(%rsp)</code>, so the first number is 1, otherwise will trigger the bomb.<br>In the next statement, we jump to the <code>phase_2 + 52</code>,in which the second number will copy to the rbx.<br>Then will get into this loop</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax</span><br><span class="line">0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax</span><br><span class="line">0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)</span><br><span class="line">0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;</span><br><span class="line">0x0000000000400f20 &lt;+36&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx</span><br><span class="line">0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx</span><br></pre></td></tr></table></figure><p>It will end until there are no number in the rbx, everytime the number will be doubled.<br>So the numbers are <code>1 2 4 8 16 32</code></p><h3 id="2-3-bomb-three"><a href="#2-3-bomb-three" class="headerlink" title="2.3 bomb three"></a>2.3 bomb three</h3><p>Check the disassemle fisrt.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function phase_3:</span><br><span class="line">=&gt; 0x0000000000400f43 &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">   0x0000000000400f47 &lt;+4&gt;:lea    0xc(%rsp),%rcx</span><br><span class="line">   0x0000000000400f4c &lt;+9&gt;:lea    0x8(%rsp),%rdx</span><br><span class="line">   0x0000000000400f51 &lt;+14&gt;:mov    $0x4025cf,%esi</span><br><span class="line">   0x0000000000400f56 &lt;+19&gt;:mov    $0x0,%eax</span><br><span class="line">   0x0000000000400f5b &lt;+24&gt;:callq  0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x0000000000400f60 &lt;+29&gt;:cmp    $0x1,%eax</span><br><span class="line">   0x0000000000400f63 &lt;+32&gt;:jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">   0x0000000000400f65 &lt;+34&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f6a &lt;+39&gt;:cmpl   $0x7,0x8(%rsp)</span><br><span class="line">   0x0000000000400f6f &lt;+44&gt;:ja     0x400fad &lt;phase_3+106&gt;</span><br><span class="line">   0x0000000000400f71 &lt;+46&gt;:mov    0x8(%rsp),%eax</span><br><span class="line">   0x0000000000400f75 &lt;+50&gt;:jmpq   *0x402470(,%rax,8)</span><br><span class="line">   0x0000000000400f7c &lt;+57&gt;:mov    $0xcf,%eax</span><br><span class="line">   0x0000000000400f81 &lt;+62&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f83 &lt;+64&gt;:mov    $0x2c3,%eax</span><br><span class="line">   0x0000000000400f88 &lt;+69&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f8a &lt;+71&gt;:mov    $0x100,%eax</span><br><span class="line">   0x0000000000400f8f &lt;+76&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f91 &lt;+78&gt;:mov    $0x185,%eax</span><br><span class="line">   0x0000000000400f96 &lt;+83&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f98 &lt;+85&gt;:mov    $0xce,%eax</span><br><span class="line">   0x0000000000400f9d &lt;+90&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400f9f &lt;+92&gt;:mov    $0x2aa,%eax</span><br><span class="line">   0x0000000000400fa4 &lt;+97&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fa6 &lt;+99&gt;:mov    $0x147,%eax</span><br><span class="line">   0x0000000000400fab &lt;+104&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fad &lt;+106&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fb2 &lt;+111&gt;:mov    $0x0,%eax</span><br><span class="line">   0x0000000000400fb7 &lt;+116&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">   0x0000000000400fb9 &lt;+118&gt;:mov    $0x137,%eax</span><br><span class="line">   0x0000000000400fbe &lt;+123&gt;:cmp    0xc(%rsp),%eax</span><br><span class="line">   0x0000000000400fc2 &lt;+127&gt;:je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">   0x0000000000400fc4 &lt;+129&gt;:callq  0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400fc9 &lt;+134&gt;:add    $0x18,%rsp</span><br><span class="line">   0x0000000000400fcd &lt;+138&gt;:retq   </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>The return value of the c function is always storaged in the eax, so the <code>0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax</code><br>compare the number of the parameters and the 0x1,it must be bigger than 1.<br>So we can input two numbers.<br>The first number must be less than 7,if the number is 1, it will jump to the <code>0x0000000000400f81</code>. In this statement we can see the second number is 311.<br>综上所述，我们可以看到最终一个可行的结果是<code>1 311</code><br>你 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Data-lab&quot;&gt;&lt;a href=&quot;#Data-lab&quot; class=&quot;headerlink&quot; title=&quot;Data lab&quot;&gt;&lt;/a&gt;Data lab&lt;/h1&gt;&lt;p&gt;鸽&lt;/p&gt;
&lt;h1 id=&quot;Bomb-lab&quot;&gt;&lt;a href=&quot;#Bomb-lab&quot; cl</summary>
      
    
    
    
    <category term="lab" scheme="http://www.halfstar.top/categories/lab/"/>
    
    
    <category term="linux" scheme="http://www.halfstar.top/tags/linux/"/>
    
    <category term="cs" scheme="http://www.halfstar.top/tags/cs/"/>
    
  </entry>
  
</feed>
